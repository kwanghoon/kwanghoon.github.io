
<html> 
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
<head> 
<TITLE>Publication</TITLE> 
<base href="https://kwanghoon.github.io"> 
</head> 
 
<body > 


<div id="topic_security"></div>

      
<h1> Software Security </h1>

<a name="webvulnerabilitytool"> <h3>전세옥, 김은총, 최광훈, 그래머 퍼징을 활용한 웹 취약점 자동
             탐색 도구 개발 및 평가, 한국정보보호학회 호남지부 추계학술대회,
    목포대학교, 2023년 9월 22일(학부생 구두 발표, 최우수논문상).</h3></a>
      <p> 본 연구에서는 웹 취약점 스캐너의 복잡한 취약점 탐지 성능을
	  향상시키기 위해 그래머 퍼저를 활용하고자 한다.  이를 위해
	  그래머 퍼저를 사용한 페이로드를 생성 방법론을 제시하였고,
	  그래머 퍼징을 적용한 웹 취약점 스캐너인 웹 퍼저를
	  개발했다. 추가적으로 효과적인 웹 취약점 탐지를 위해 크롤링,
	  비동기, 병렬 처리의 중요성을 강조했다.
      </p>
	  <h4> Available in:
	    <!-- <a href="">PDF</a> -->
	  </h4>

	  <hr>
	  
<a name="websecurityinlinks"> <h3>다계층 프로그래밍언어 Links의 웹 취약점 분석 (A Web vulnerability analysis of multi-tier language Links)</h3></a>
이규해, 창병모, 최광훈, 한국소프트웨어종합학술대회(KSC2022), 2022년 12월20일-23일.

      <p>
다계층 프로그래밍 언어(Multi-tier programming language)란 시스템의 각
계층의 구성 요소를 같은 컴파일 단위로 혼합해 개발과정 중 오류가
발생하기 쉬운 단점을 개선하기 위해 제안된 언어이다. 그 결과 각 계층을
개발할 때 발생할 수 있는 오류를 줄이는 장점이 있다. 그러나 현재까지
다계층 프로그래밍 언어로 작성한 웹 프로그램의 취약점을 분석하는 연구가
없었다. 이러한 다계층 프로그래밍 언어의 한 종류인 Links로 작성된
프로그램을 대상으로 Links 프로그램의 웹 취약점을 분석한 결과를 리포트
한다.
	<br>
	(이 논문은 OWASP ZAP을 이용한 다계층 프로그래밍 언어 Links의 웹 취약점 분석(이규해, 창병모, 최광훈, 한국소프트웨어종합학술대회-KSC2021, 2021년 12월20일-22일) 포스터 논문을 확장한 구두 발표 논문임)

	</P>

	  <h4> Available in:
	    <!-- <a href="">PDF</a> -->
	  </h4>
    
      <hr>

	
	  <a name="smcstaticanalyzer"> <h3>자체수정 코드를 탐지하는 정적 분석 방법의 LLVM 프레임워크 기반 구현 및 실험 (An LLVM-Based Implementation of Static Analysis for Detecting Self-Modifying Code and Its Evaluation)</h3>
	    유재일, 최광훈,
	    한국정보보호학회 논문지, 32권, 2호, Pages 171-179, 2022년 4월.

	    <p>
자체 수정 코드(Self-Modifying-Code)란 실행 시간 동안 스스로 실행
코드를 변경하는 코드를 말한다. 이런 기법은 특히 악성코드가 정적 분석을
우회하는 데 악용된다. 따라서 이러한 악성코드를 효과적으로 검출하려면
자체 수정 코드를 파악하는 것이 중요하다. 그동안 동적 분석 방법으로
자체 수정 코드를 분석해왔으나 이는 시간과 비용이 많이 든다. 만약 정적
분석으로 자체 수정 코드를 검출할 수 있다면 악성코드 분석에 큰 도움이
될 것이다.  본 논문에서는 LLVM IR로 변환한 바이너리 실행 프로그램을
대상으로 자체 수정 코드를 탐지하는 정적 분석방법을 제안하고, 자체 수정
코드 벤치마크를 만들어 이 방법을 적용했다. 본 논문의 실험 결과
벤치마크 프로그램을 컴파일로 변환한 최적화된 형태의 LLVM IR 프로그램에
대해서는 설계한 정적 분석 방법이 효과적이었다. 하지만 바이너리를
리프팅 변환한 비정형화된 LLVM IR 프로그램에 대해서는 자체 수정 코드를
검출하기 어려운 한계가 있었다. 이를 극복하기 위해 바이너리를 리프팅
하는 효과적인 방법이 필요하다.
	    </P>

	    <p>
Self-Modifying-Code is a code that changes the code by itself during
execution time. This technique is particularly abused by malicious
code to bypass static analysis. Therefor, in order to effectively
detect such malicious codes, it is important to identify
self-modifying-codes. In the meantime, Self-modify-codes have been
analyzed using dynamic analysis methods, but this is time-consuming
and costly. If static analysis can detect self-modifying-code it will
be of great help to malicious code analysis.  In this paper, we
propose a static analysis method to detect self-modified code for
binary executable programs converted to LLVM IR and apply this method
by making a self-modifying-code benchmark. As a result of the
experiment in this paper, the designed static analysis method was
effective for the standardized LLVM IR program that was compiled and
converted to the benchmark program. However, there was a limitation in
that it was difficult to detect the self-modifying-code for the
unstructured LLVM IR program in which the binary was lifted and
transformed. To overcome this, we need an effective way to lift the
binary code.
	      </P>

	    <h4> Available in:
		<a href="https://www.dbpia.co.kr/journal/articleDetail?nodeId=NODE11056765">LINK</a>
		</h3>

<hr>

    <a name="securecodingforiot"><h3> A GQM Approach to Evaluation of the Quality of SmartThings
	Applications Using Static Analysis</h3>
    Byeong-Mo Chang, Janine Cassandra Son, Kwanghoon Choi
      KSII Transactions on Internet and Information Systems, 14(6), June 2020.
      
      <p>
SmartThings is one of the most popular open platforms for home
automation IoT solutions that allows users to create their own
applications called SmartApps for personal use or for public
distribution. The nature of openness demands high standards on the
quality of SmartApps, but there have been few studies that have
evaluated this thoroughly yet. As part of software quality practice,
code reviews are responsible for detecting violations of coding
standards and ensuring that best practices are followed. The purpose
of this research is to propose systematically designed quality metrics
under the well-known Goal/Question/Metric methodology and to evaluate
the quality of SmartApps through automatic code reviews using a static
analysis. We first organize our static analysis rules by following the
GQM methodology, and then we apply the rules to real-world SmartApps
to analyze and evaluate them. A study of 105 officially published and
74 community-created real-world SmartApps found a high ratio of
violations in both types of SmartApps, and of all violations, security
violations were most common. Our static analysis tool can effectively
inspect reliability, maintainability, and security violations. The
results of the automatic code review indicate the common violations
among SmartApps.
      </p>
      
      <h4> Available in:
	<a href="http://itiis.org/digital-library/23583">PDF</a>
	</h4>

      <hr>
      
      <h3>A Practical Intent Fuzzing Tool for Robustness of Inter-Component Communication in Android Apps</h3>
	Kwanghoon Choi, Myungpil Ko, Byeong-Mo Chang, KSII Transactions on Internet and Information Systems, Vol.12, Issue 9, pp.4248-4270, September 30, 2018.
  <p>This research aims at a new practical Intent fuzzing tool for detecting Intent vulnerabilities
of Android apps causing the robustness problem. We proposed two new ideas. First, we
designed an Intent specification language to describe the structure of Intent, which makes our
Intent fuzz testing tool flexible. Second, we proposed an automatic tally method classifying
unique failures. With the two ideas, we implemented an Intent fuzz testing tool called Hwacha,
and evaluated it with 50 commercial Android apps. Our tool offers an arbitrary combination of
automatic and manual Intent generators with executors such as ADB and JUnit due to the use
of the Intent specification language. The automatic tally method excluded almost 80% of
duplicate failures in our experiment, reducing efforts of testers very much in review of failures.
The tool uncovered more than 400 unique failures including what is unknown so far. We also
measured execution time for Intent fuzz testing, which has been rarely reported before. Our
tool is practical because the whole procedure of fuzz testing is fully automatic and the tool is
applicable to the large number of Android apps with no human intervention.
    </p>

  <h4> Available in:
    <a href="https://www.itiis.org/journals/tiis/digital-library/manuscript/file/21866/TIISVol12No9-8.pdf">PDF</a>
	</h4>
  <hr>

  <h3>웨어러블 어플리케이션 개발을 위한 안드로이드 BLE 에뮬레이터
  </h3>

  문현아,박수용,최광훈, 정보과학회 컴퓨팅의 실제 논문지(KTCP), 2018년2월. 


      <p>사물 인터넷 환경에서 모바일 어플리케이션과 웨어러블 기기를
연동하기 위해 BLE (Bluetooth Low Energy) 기반 통신을 많이 활용하고
있다. 특히 BLE 연동 안드로이드 어플리케이션을 개발할 때 개발 환경에서
BLE 에뮬레이션을 지원하지 않아 반드시 웨어러블 기기가 필요한 제약이 있
다. 본 연구에서는 처음으로 안드로이드 BLE 에뮬레이터를 설계 및
구현하였다. 이를 활용하여 웨어러블 기기가 없어도 BLE 연동
어플리케이션을 개발할 수 있음을 확인하였다. 그리고 그래프 모델 기반의
안 드로이드 BLE 시나리오 자동 생성 방법을 제안하고 자동 생성한
시나리오들을 제안한 안드로이드 BLE 에뮬레이터 상에서 실행하여
어플리케이션의 BLE 응용 프로토콜을 체계적으로 테스트하는데 유용함을
보였다.
      </p>
      <p>
BLE (Bluetooth Low Energy) has been extensively used for communication
between mobile applications and wearable devices in IoT (Internet of
Things). In developing Android applications, wearable devices, on
which the applications can run, should be available because the
existing Android SDK does not support any BLE emulation facility. In
this study, we have designed and implemented the first Android BLE
emulator. Using this, we are able to develop and test BLE-based
Android applications even when without wearable devices. We have also
proposed an automatic generation method of Android BLE scenarios based
on graph model. We have shown that the method is useful for
systematically testing BLE application protocols by running the
generated scenarios on the Android BLE emulator.
	</p>

      <h4>Available in:
	<a href="/paper/KIISE2017_BLE_1217_final.pdf">PDF</a></h4>
      <hr>

      <h3>A Lightweight Approach to Component-Level Exception Mechanism for Robust Android Apps</h3>
      Kwanghoon Choi, Byeong-Mo Chang, Computer Languages, Systems, and Structures, Vol.44, Part C, P.283-298, December 2015.
      
      <p>
	Recent researches have reported that Android programs are vulnerable to unexpected exceptions. One reason is that the current design of Android platform solely depends on Java exception mechanism, which is unaware of the component-based structure of Android programs. This paper proposes a component-level exception mechanism for programmers to build robust Android programs with. With the mechanism, they can define an intra-component handler for each component to recover from exceptions, and they can propagate uncaught exceptions to caller component along the reverse of component activation flow. Theoretically, we have formalized an Android semantics with exceptions to prove the robustness property of the mechanism. In practice, we have implemented the mechanism with a domain-specific library that extends existing Android components. This lightweight approach does not demand the change of the Android platform. In our experiment with Android benchmark programs, the library is found to catch a number of runtime exceptions that would otherwise get the programs terminated abnormally. We also measure the overhead of using the library to show that it is very small. Our proposal is a new mechanism for defending Android programs from unexpected exceptions.
    </p>

  <h4> Available in:
    <a href="http://www.sciencedirect.com/science/article/pii/S1477842415300038">PDF</a>
	</h4>
  <hr>      

  <h3>NFC 프로그램 메시지 방식에서 변조 방지와 사용자에 의한 동적 접근 제어 방법</h3>

  고명필,최광훈,임효상, 정보과학회논문지: 컴퓨팅의 실제 및 레터, 제19권, 제12호, pp624-629, 2013년 12월.

      <p>안드로이드 기반 스마트폰 앱의 바이너리 코드를 오프라인 상에서
      분석하여 유해 사이트 목록에 포함된 서버에 접속하는지
      여부를판단하는 시스템을 제안하고, 실제 앱에 대해 적용한 실험
      결과를 제시한다. 주어진 앱의 바이너리 코드를 Java 바이트 코드로
      역 컴파일하고, 문자열분석을 적용하여 프로그램에서 사용하는 모든
      문자열 집합을 계산한 다음, 유해 매체물을 제공하는 사이트 URL을
      포함하는지 확인하는방법이다. 이 시스템은 앱을 실행하지 않고 배포
      단계에서 검사할 수 있고 앱 마켓 관리에서 유해 사이트를 접속하는
      앱을 분류하는 작업을자동화할 수 있는 장점이 있다. DNS 서버를
      이용하거나 스마트폰에 모니터링 모듈을 설치하여 차단하는 기존
      방법들과 서로 다른 단계에서유해앱을 차단함으로써 상호 보완할 수
      있는 방법이 될 수 있다.
      </p>
      <p>This paper proposes a method of forgery protection and user’s dynamic access control
in NFC standards compliant program messages. We implement this proposal in Android phones to test
mobile applicability. The sizes of benchmark program messages are small enough to be stored in stock
NFC tags, and the total execution time increased due to employing the two security methods is not
noticeable to users in NFC service.
	</p>

      <h4>Available in:
	<a href="/paper/kiiseLetter2013.pdf">PDF</a></h4>
  <hr>
      
  <h3>유해사이트를 접속하는 안드로이드 앱을 문자열 분석으로 검사하는 시스템</h3>

  최광훈, 고광만, 박희완, 윤종희, 정보처리학회 논문지A,Vol.19-A, No.4, pp187-194, August 2012. 
  문현아,박수용,최광훈, 정보과학회 컴퓨팅의 실제 논문지(KTCP), 2018년2월. 


      <p>안드로이드 기반 스마트폰 앱의 바이너리 코드를 오프라인 상에서
      분석하여 유해 사이트 목록에 포함된 서버에 접속하는지
      여부를판단하는 시스템을 제안하고, 실제 앱에 대해 적용한 실험
      결과를 제시한다. 주어진 앱의 바이너리 코드를 Java 바이트 코드로
      역 컴파일하고, 문자열분석을 적용하여 프로그램에서 사용하는 모든
      문자열 집합을 계산한 다음, 유해 매체물을 제공하는 사이트 URL을
      포함하는지 확인하는방법이다. 이 시스템은 앱을 실행하지 않고 배포
      단계에서 검사할 수 있고 앱 마켓 관리에서 유해 사이트를 접속하는
      앱을 분류하는 작업을자동화할 수 있는 장점이 있다. DNS 서버를
      이용하거나 스마트폰에 모니터링 모듈을 설치하여 차단하는 기존
      방법들과 서로 다른 단계에서유해앱을 차단함으로써 상호 보완할 수
      있는 방법이 될 수 있다.
      </p>
      <p>This paper proposes a string analysis based system for classifying Android Apps that may access so called harmful sites, and shows
an experiment result for real Android apps on the market. The system first transforms Android App binary codes into Java byte codes, it
performs string analysis to compute a set of strings at all program points, and it classifies the Android App as bad ones if the computed
set contains URLs that are classified because the sites provide inappropriate contents. In the proposed approach, the system performs such
a classification in the stage of distribution before installing and executing the Apps. Furthermore, the system is suitable for the automatic
management of Android Apps in the market. The proposed system can be combined with the existing methods using DNS servers or
	monitoring modules to identify harmful Android apps better in different stages.
	</p>

      <h4>Available in:
	<a href="/paper/KIPS2012_3.pdf">PDF</a></h4>
      <hr>

      <h3>안드로이드를 위한 난독화 도구 프로가드(Proguard) 성능 평가</h3>
      박희완, 박희광, 고광만, 최광훈, 윤종희, 한국정보처리학회 학술대회논문집, vol. 19, no. 1, pp. 730-733, 2012.
      
      <p>소프트웨어는 대부분 바이너리 형태로 배포되기 때문에 역공학
      분석이 쉽지 않다. 그러나 안드로이드는 자바를 기반으로 한다. 즉,
      자바 언어로 프로그래밍하고 생성된 클래스 파일을 dx라는 도구를
      사용하여 안드로이드용 달빅(Dalvik) 코드로 변환한다. 따라서
      안드로이드 역시 자바의 취약점을 가지고 있고, 자바용으로 개발된
      역공학 도구에 의해서 쉽게 분석될 수 있다. 한편으로 자바
      프로그램의 저작권을 보호하고 핵심 알고리즘이 노출되지 않도록
      다양한 난독화 도구들이 개발되었다. 그 중에서 안드로이드 SDK에
      포함되어 함께 배포되고 있기 때문에 널리 사용되고 있는
      프로가드(Proguard)에 대해서 대표적인 기능 및 사용법, 프로가드로
      난독화된 코드가 원본과 비교하여 어떻게 변경되었는지
      평가한다. 그리고 프로가드가 가지고 있는 한계를 알아보고, 이것을
      극복할 수 있는 방법을 모색한다.
      </p>

      <h4>Availabe in: <a href="https://kiss.kstudy.com/Detail/Ar?key=3873387">Link</a></h4>
      <hr>


  <h3>SMS 부호화 복호화 모듈 검증 방법에 대한 연구(A Study on the Verification Scheme of SMS Encoding and Decoding Module)</h3>
      최광훈, SMS 부호화 복호화 모듈 검증 방법에 대한 연구, 한국컴퓨터정보학회 논문지, 15권, 6호, pp.1~9, 2010년 6월.
      
  <p>본 논문에서는 3GPP(3rd Generation Partnership Project)에서 정의한 SMS PDU (Protocol Data Unit) 포맷을 주어진 SMS 부호화 복호화 모듈에서 정확하게 구현했는지 검증하는 방법을 제안한다. 기존 SMS 관련 도구들은 SMS 게이트웨이를 통해 송수신하거나 또는 SMS PDU 해석을 목적으로 개발되어 3GPP에서 정의한 세부 SMS PDU 규격에 따라 정확히 구현했는지 테스트하는 용도로는 적합하지 않다. 본 논문에서 제안한 방법은 함수형 언어 Haskell로 작성된 QuickCheck 라이브러리를 활용해 3GPP에서 정의한 구조에 맞는 SMS PDU 테스트 데이터를 자동 생성하여 SMS 부호화 복호화 모듈을 테스트한다. C언어로 작성된 리눅스 모바일 플랫폼 SMS 모듈에 적용하여 이 모듈의 부호화 복호화 기능을 테스트한 결과 BCD 포맷 시간 정보를 잘못 해석하는 사례 등 중요한 오류들을 발견할 수 있었다. 제안한 방법은 3GPP에서 정의한 규격에 맞추어 SMS PDU를 생성하기 때문에 일반적인 SMS 모듈들에 모두 적용 가능한 장점을 지닌다. 본 논문에서 사용한 방법과 같이 QuickCheck 라이브러리를 통해 다른 네트워크 프로토콜 데이터 규격에 대한 부호화 복호화 검증에도 응용할 수 있을 것이다.


This paper proposes a test method for compliance of SMS encoder and decoder modules with 3GPP (3rd Generation Partnership Project) specification on SMS PDU (Protocol Data Unit). The existing tools have focused on providing an SMS gateway and on helping to view and edit a single SMS PDU, which rarely help to resolve the compliance test problem. The proposed compliance test method is based on an automatic generation of SMS PDUs fully compliant with the 3GPP specification by using QuickCheck library written in Haskell. By applying the proposed method to a C-based SMS encoder and decoder in Linux Mobile platform, we have found out several critical bugs such as wrong interpretation of time stamps in BCD format. The automatic SMS PDU generator is reusable in that it only depends on the 3GPP SMS specification. The QuickCheck library is also applicable for testing other network protocol data encoders and decoders, as used in this paper.
    </p>

  <h4> Available in:
    <a href="https://www.itiis.org/journals/tiis/digital-library/manuscript/file/21866/TIISVol12No9-8.pdf">PDF</a>,
    <a href="https://hackage.haskell.org/package/GenSmsPdu">Haskell package</a>
	</h4>
  <hr>
  
  
</html> 

